(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
module.exports = function(strings) {
  if (typeof strings === 'string') strings = [strings]
  var exprs = [].slice.call(arguments,1)
  var parts = []
  for (var i = 0; i < strings.length-1; i++) {
    parts.push(strings[i], exprs[i] || '')
  }
  parts.push(strings[i])
  return parts.join('')
}

},{}],2:[function(require,module,exports){
// Generated by LiveScript 1.3.1
var glslify, cloud;
glslify = require('glslify');
cloud = require("./sample/cloud");
window.addEventListener('load', function(){
  var shader, renderer;
  shader = {
    fragmentShader: glslify(["precision highp float;\n#define GLSLIFY 1\n/* z: pixel size */\nvec3 aspect_ratio_1540259130(vec2 res, int iscover) {\n  // iscover: 0 = contains, 1 = cover\n  float r;\n  vec3 ret = vec3((gl_FragCoord.xy / res.xy),0);\n  if(iscover == 0 ^^ res.x > res.y) {\n    r = res.y / res.x;\n    ret.y = ret.y * r - (r - 1.) * 0.5;\n    ret.z = 1. / (iscover == 0 ? res.x : res.y);\n  } else {\n    r = res.x / res.y;\n    ret.x = (ret.x * r) - (r - 1.) * 0.5;\n    ret.z = 1. / (iscover == 0 ? res.y : res.x);\n  }\n  return ret;\n}\n\nvec2 quantize(float value, float step) {\n  vec2 ret;\n  value = smoothstep(0., 1., value) * (step + 1.);\n  ret = vec2(floor(value) / (step + 1.), fract(value));\n  return ret;\n}\n\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\nfloat noise(float x) {\n        float i = floor(x);\n        float f = fract(x);\n        float u = f * f * (3.0 - 2.0 * f);\n        return mix(hash(i), hash(i + 1.0), u);\n}\n\nfloat noise(vec2 x) {\n        vec2 i = floor(x);\n        vec2 f = fract(x);\n\n        // Four corners in 2D of a tile\n        float a = hash(i);\n        float b = hash(i + vec2(1.0, 0.0));\n        float c = hash(i + vec2(0.0, 1.0));\n        float d = hash(i + vec2(1.0, 1.0));\n\n        // Simple 2D lerp using smoothstep envelope between the values.\n        // return vec3(mix(mix(a, b, smoothstep(0.0, 1.0, f.x)),\n        //                      mix(c, d, smoothstep(0.0, 1.0, f.x)),\n        //                      smoothstep(0.0, 1.0, f.y)));\n\n        // Same code, with the clamps in smoothstep and common subexpressions\n        // optimized away.\n        vec2 u = f * f * (3.0 - 2.0 * f);\n        return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n// This one has non-ideal tiling properties that I'm still tuning\nfloat noise(vec3 x) {\n        const vec3 step = vec3(110, 241, 171);\n\n        vec3 i = floor(x);\n        vec3 f = fract(x);\n \n        // For performance, compute the base input to a 1D hash from the integer part of the argument and the \n        // incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n        vec3 u = f * f * (3.0 - 2.0 * f);\n        return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm(float x) {\n  float v = 0.0;\n  float a = 0.5;\n  float shift = float(100);\n  for (int i = 0; i < NUM_OCTAVES; ++i) {\n    v += a * noise(x);\n    x = x * 2.0 + shift;\n    a *= 0.5;\n  }\n  return v;\n}\n\nfloat fbm(vec2 x) {\n  float v = 0.0;\n  float a = 0.5;\n  vec2 shift = vec2(100);\n  // Rotate to reduce axial bias\n  mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n  for (int i = 0; i < NUM_OCTAVES; ++i) {\n    v += a * noise(x);\n    x = rot * x * 2.0 + shift;\n    a *= 0.5;\n  }\n  return v;\n}\n\nfloat fbm(vec3 x) {\n  float v = 0.0;\n  float a = 0.5;\n  vec3 shift = vec3(100);\n  for (int i = 0; i < NUM_OCTAVES; ++i) {\n    v += a * noise(x);\n    x = x * 2.0 + shift;\n    a *= 0.5;\n  }\n  return v;\n}\n\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n    + i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nvec3 raster_gradient_3d1_1117569599(vec2 uv, vec3 c1, vec3 c2, vec3 c3, float rate) {\n  return (\n    c1 * ( sin(rate * uv.x) * 0.5 + 0.5 ) + \n    c2 * ( sin(rate * uv.y) * 0.5 + 0.5 ) +\n    c3 * ( sin(rate * uv.x * uv.y) * 0.5 + 0.5 )\n  );\n}\n\nuniform float uTime;\nuniform vec2 uResolution;\n\nvoid main() {\n  vec3 uv = aspect_ratio_1540259130(uResolution, 1);\n  float f = pow(pow(uv.x, 2.) - pow(uv.y, 2.), 1.7);\n  vec3 c2 = vec3(.06, .45, .83);\n  vec3 c1 = vec3(.76, .91, .81);\n\n  gl_FragColor = vec4(mix(c1, c2, f), 1.);\n}"])
  };
  /*
  vec3 raster_gradient_3d1(vec2 uv, vec3 c1, vec3 c2, vec3 c3, float rate) {
    return (
      c1 * ( sin(rate * uv.x) * 0.5 + 0.5 ) + 
      c2 * ( sin(rate * uv.y) * 0.5 + 0.5 ) +
      c3 * ( sin(rate * uv.x * uv.y) * 0.5 + 0.5 )
    );
  }
  */
  renderer = new ShaderRenderer([shader], {
    root: '#root'
  });
  renderer.init();
  return renderer.animate();
});
},{"./sample/cloud":3,"glslify":1}],3:[function(require,module,exports){
// Generated by LiveScript 1.3.1
var glslify;
glslify = require('glslify');
module.exports = {
  fragmentShader: glslify(["precision highp float;\n#define GLSLIFY 1\nvec3 raster_gradient_3d1_1540259130(vec2 uv, vec3 c1, vec3 c2, vec3 c3, float rate) {\n  return (\n    c1 * ( sin(rate * uv.x) * 0.5 + 0.5 ) + \n    c2 * ( sin(rate * uv.y) * 0.5 + 0.5 ) +\n    c3 * ( sin(rate * uv.x * uv.y) * 0.5 + 0.5 )\n  );\n}\n\nuniform vec2 uResolution;\nuniform float uTime;\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / uResolution.xy;\n  vec3 pos;\n  float t = uTime * 0.1;\n  float c = 0.5;\n  float len;\n  /*\n  for(int i=0;i<100;i++) {\n    pos.x = fract(sin(float(i) * 52.643) * 735.5373) + sin(t + float(i)); \n    pos.y = fract(fract(sin(float(i) * 63.235) * 644.5346) - t);\n    pos.z = fract(sin(float(i) * 12.345) * 678.9012) * 0.01;\n    len = clamp(length(uv - pos.xy) - pos.z, 0., 1.);\n    c += 0.5 * pow(1. - len, 15.);\n  }\n  */\n  c = 1.;\n  gl_FragColor = vec4(\n    c * vec3(raster_gradient_3d1_1540259130(uv, vec3(1.,0.,0.), vec3(0.,1.,0.), vec3(0.,0.,1.), 3.)),\n    1.\n  );\n}"])
};
/*
#extension GL_OES_standard_derivatives : enable 

// DOF Snowfield! 
// Mouse X controls focal depth 

uniform float time; 
uniform vec2 mouse; 
uniform vec2 resolution; 

vec3 snowflake(vec3 coords, vec2 pxPos) { 

  float focalPlane = 0.5 + 4.0 * abs(sin(time)) * 0.5; 
  float iris = 0.0001 + 0.01 * abs(sin(time));

  float pxDiam = abs(coords.z - focalPlane) * iris; 
  vec2 flakePos = vec2(coords.xy) / coords.z; 
  float flakeDiam = 0.003 / coords.z; 

  float dist = length(pxPos - flakePos); 
  float bri = (pxDiam + flakeDiam - dist) / (pxDiam * 2.0); 
  if (pxDiam > flakeDiam) { 
    bri /= (pxDiam / flakeDiam); 
  } 

  return vec3(0.7, 0.9, 1.0) * min(1.0, max(0.0, bri)); 
} 

void main( void ) { 

  vec2 pos = ( gl_FragCoord.xy / resolution.xy ) - 0.5; 
  pos.y *= resolution.y / resolution.x; 

  gl_FragColor.rgb = vec3(0.04, 0.13, 0.19); 

  for (int i=0; i<150; i++) { 

    vec3 c = vec3(0); 
    c.z = fract(sin(float(i) * 25.643) * 735.5373); 
    c.z *= 0.2 + fract(sin(float(i) * 74.753) * 526.5463); 
    c.z = 0.5 + (1.0 - c.z) * 2.4; 
    float gSize = 0.5 / c.z; 
    vec2 drift = vec2(0); 
    drift.x = fract(sin(float(i) * 52.3464) * 353.43354) * 4.0; 
    drift.x = drift.x + time * 0.06 + 4.0 * sin(time * 0.03 + c.z * 7.0); 
    drift.y = fract(sin(float(i) * 63.2356) * 644.53463) * 4.0; 
    drift.y = drift.y + time * -0.2; 
    drift /= c.z; 

    vec2 grid = vec2(mod((pos.x+drift.x)/c.z, gSize), mod((pos.y-drift.y)/c.z, gSize)); 
    c.x += gSize*0.5; 
    c.y += gSize*0.5; 
    gl_FragColor.rgb += snowflake(c, grid); 

  } 
  gl_FragColor.a = 1.0; 

}
*/
},{"glslify":1}]},{},[2]);
