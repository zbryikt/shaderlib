// Generated by LiveScript 1.3.1
var shaderRenderer;
shaderRenderer = function(root, shader){
  var canvas, gl;
  this.root = root = typeof root === 'string' ? document.querySelector(root) : root;
  this.shader = shader;
  this.domElement = canvas = document.createElement('canvas');
  this.gl = gl = null;
  return this;
};
shaderRenderer.prototype = import$(Object.create(Object.prototype), {
  init: function(){
    var canvas, box, buffer, program, positionLocation;
    canvas = this.domElement;
    this.root.appendChild(canvas);
    box = this.root.getBoundingClientRect();
    this.width = box.width;
    this.height = box.height;
    this.inited = true;
    this.gl = canvas.getContext('webgl');
    canvas.width = this.width;
    canvas.height = this.height;
    this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);
    buffer = this.gl.createBuffer();
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array([-1, -1, 0, 1, -1, 0, -1, 1, 0, -1, 1, 0, 1, -1, 0, 1, 1, 0]), this.gl.STATIC_DRAW);
    program = this.makeProgram(this.shader);
    this.gl.useProgram(program);
    positionLocation = this.gl.getAttribLocation(program, "position");
    this.gl.enableVertexAttribArray(positionLocation);
    return this.gl.vertexAttribPointer(positionLocation, 3, this.gl.FLOAT, false, 0, 0);
  },
  makeShader: function(code, type){
    var shader;
    shader = this.gl.createShader(type);
    this.gl.shaderSource(shader, code);
    this.gl.compileShader(shader);
    if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
      console.log(this.gl.getShaderInfoLog(shader));
    }
    return shader;
  },
  makeProgram: function(shader){
    var program, shaders, vs, fs;
    this.program = program = this.gl.createProgram();
    shaders = [];
    vs = this.makeShader(this.shader.vertexShader, this.gl.VERTEX_SHADER);
    fs = this.makeShader(this.shader.fragmentShader, this.gl.FRAGMENT_SHADER);
    this.gl.attachShader(program, vs);
    this.gl.attachShader(program, fs);
    this.gl.linkProgram(program);
    if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {}
    return program;
  },
  animate: function(cb){
    var _, this$ = this;
    _ = function(t){
      requestAnimationFrame(function(t){
        return _(t * 0.001);
      });
      cb(t);
      return this$.render(t);
    };
    return _(0);
  },
  render: function(t){
    var uTime, uResolution, k, ref$, v, u;
    t == null && (t = 0);
    if (!this.inited) {
      this.init();
    }
    uTime = this.gl.getUniformLocation(this.program, "uTime");
    this.gl.uniform1f(uTime, t);
    uResolution = this.gl.getUniformLocation(this.program, "uResolution");
    this.gl.uniform2fv(uResolution, [this.width, this.height]);
    for (k in ref$ = this.shader.uniforms || {}) {
      v = ref$[k];
      u = this.gl.getUniformLocation(this.program, k);
      this.gl["uniform" + v.type](u, v.value);
    }
    this.gl.clearColor(1, 0, 0, 1);
    this.gl.clear(this.gl.COLOR_BUFFER_BIT);
    return this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
  }
});
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}