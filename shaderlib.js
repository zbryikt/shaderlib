shaderlib.module.register({"src/aspectRatio":"vec2 aspectRatio(vec2 input, vec2 res, int iscover) {\n  // iscover: 0 = contains, 1 = cover\n  if(iscover == 0 ^^ resolution.x > resolution.y) {\n    r = resolution.y / resolution.x;\n    vUv.y = vUv.y * r - (r - 1.) * 0.5;\n  } else {\n    r = resolution.x / resolution.y;\n    vUv.x = (vUv.x * r) - (r - 1.) * 0.5;\n  }\n}\n","src/blend/add":"float blend_add(float a, float b) {\n  return min(a + b, 1.);\n}\n\nvec3 blend_add(vec3 a, vec3 b) {\n  return min(a + b, 1.);\n}\n\nvec4 blend_add(vec4 a, vec4 b) {\n  return vec4((blend_add(vec3(a), vec3(b)) * b.a + vec3(a) * (1. - b.a)), a.a);\n}\n","src/blend/average":"float blend_average(float a, float b) {\n  return (a + b) / 2.;\n}\n\nvec3 blend_average(vec3 a, vec3 b) {\n  return (a + b) / 2.;\n}\n\nvec4 blend_average(vec4 a, vec4 b) {\n  return vec4((blend_average(vec3(a), vec3(b)) * b.a + vec3(a) * (1. - b.a)), a.a);\n}\n","src/blend/blend":"float blend_add(float a, float b) {\n  return min(a + b, 1.);\n}\n\nfloat blend_darken(float a, float b) {\n  return min(a, b);\n}\n\nfloat blend_multiply(float a, float b) {\n  return a * b;\n}\n\nfloat blend_colorburn(float a, float b) {\n  return 1. - ( 1. - a ) * b;\n}\n\nfloat blend_linearburn(float a, float b) {\n  return clamp(a + b - 1., 0., 1.);\n}\n\nfloat blend_lighten(float a, float b) {\n  return max(a, b);\n}\n\nfloat blend_screen(float a, float b) {\n  return 1. - (1. - a) * (1. - b);\n}\n\nfloat blend_colordodge(float a, float b) {\n  return clamp(a / ( 1. - b), 0., 1.);\n}\n\nfloat blend_lineardodge(float a, float b) {\n  return clamp(a + b, 0., 1.);\n\n}\n\nfloat blend_overlay(float a, float b) {\n  return a < 0.5 ? (2 * a * b) : (1. - 2 * (1. - a) * (1. - b));\n}\n\nfloat blend_softlight(float a, float b) {\n  return b < 0.5 \n  if(b < 0.5) { return a * (b + 0.5); }\n  return 1. - (1. - a) * (1. - \n}\n","src/blend/colorburn":"float blend_colorburn(float a, float b) {\n  return b == 0. ? b : max(1. - (1. - a) / b, 0.);\n}\n\nvec3 blend_colorburn(vec3 a, vec3 b) {\n  return vec3(\n    blend_colorburn(a.r, b.r),\n    blend_colorburn(a.g, b.g),\n    blend_colorburn(a.b, b.b)\n  );\n}\n\nvec4 blend_colorburn(vec4 a, vec4 b) {\n  return vec4((blend_colorburn(vec3(a), vec3(b)) * b.a + vec3(a) * (1. - b.a)), a.a);\n}\n","src/blend/colordodge":"float blend_colordodge(float a, float b) {\n  return b == 1. ? b : min(a / (1. - b), 0.);\n}\n\nvec3 blend_colordodge(vec3 a, vec3 b) {\n  return vec3(\n    blend_colordodge(a.r, b.r),\n    blend_colordodge(a.g, b.g),\n    blend_colordodge(a.b, b.b)\n  );\n}\n\nvec4 blend_colordodge(vec4 a, vec4 b) {\n  return vec4((blend_colordodge(vec3(a), vec3(b)) * b.a + vec3(a) * (1. - b.a)), a.a);\n}\n","src/blend/darken":"float blend_darken(float a, float b) {\n  return min(a, b);\n}\n\nvec3 blend_darken(vec3 a, vec3 b) {\n  return min(a, b);\n}\n\nvec4 blend_darken(vec4 a, vec4 b) {\n  return vec4((blend_darken(vec3(a), vec3(b)) * b.a + vec3(a) * (1. - b.a)), a.a);\n}\n","src/blend/difference":"float blend_difference(float a, float b) {\n  return abs(a - b);\n}\n\nvec3 blend_difference(vec3 a, vec3 b) {\n  return abs(a - b);\n}\n\nvec4 blend_difference(vec4 a, vec4 b) {\n  return vec4((blend_difference(vec3(a), vec3(b)) * b.a + vec3(a) * (1. - b.a)), a.a);\n}\n","src/blend/exclusion":"float blend_exclusion(float a, float b) {\n  return a + b - 2. * a * b;\n}\n\nvec3 blend_exclusion(vec3 a, vec3 b) {\n  return a + b - 2. * a * b;\n}\n\nvec4 blend_exclusion(vec4 a, vec4 b) {\n  return vec4((blend_exclusion(vec3(a), vec3(b)) * b.a + vec3(a) * (1. - b.a)), a.a);\n}\n","src/blend/glow":"float blend_glow(float a, float b) {\n  return a == 1. ? a : min(b * b / (1. - a), 1.);\n}\n\nvec3 blend_glow(vec3 a, vec3 b) {\n  return vec3(\n    blend_glow(a.r, b.r),\n    blend_glow(a.g, b.g),\n    blend_glow(a.b, b.b)\n  );\n}\n\nvec4 blend_glow(vec4 a, vec4 b) {\n  return vec4((blend_glow(vec3(a), vec3(b)) * b.a + vec3(a) * (1. - b.a)), a.a);\n}\n","src/blend/hardlight":"float blend_hardlight(float a, float b) {\n  return a < 0.5 ? 2. * b * a : 1. - (2. * (1. - b) * (1. - a));\n}\n\nvec3 blend_hardlight(vec3 a, vec3 b) {\n  return vec3(\n    blend_hardlight(a.r, b.r),\n    blend_hardlight(a.g, b.g),\n    blend_hardlight(a.b, b.b)\n  );\n}\n\nvec4 blend_hardlight(vec4 a, vec4 b) {\n  return vec4((blend_hardlight(vec3(a), vec3(b)) * b.a + vec3(a) * (1. - b.a)), a.a);\n}\n","src/blend/hardmix":"float blend_hardmix(float a, float b) {\n  return ( ( b < 0.5\n    ? ( b == 0. ? 2. * b : max(1. - (1. - a) / (2. * b), 0.) )\n    : ( 2. * (b - 0.5) == 1. ? 2. * (b - 0.5) : min(a / (1. - (2. * (b - 0.5))), 0.))\n  ) < 0.5 ? 0.0 : 1.0 );\n}\n\nvec3 blend_hardmix(vec3 a, vec3 b) {\n  return vec3(\n    blend_hardmix(a.r, b.r),\n    blend_hardmix(a.g, b.g),\n    blend_hardmix(a.b, b.b)\n  );\n}\n\nvec4 blend_hardmix(vec4 a, vec4 b) {\n  return vec4((blend_hardmix(vec3(a), vec3(b)) * b.a + vec3(a) * (1. - b.a)), a.a);\n}\n","src/blend/lighten":"float blend_lighten(float a, float b) {\n  return max(a, b);\n}\n\nvec3 blend_lighten(vec3 a, vec3 b) {\n  return max(a, b);\n}\n\nvec4 blend_lighten(vec4 a, vec4 b) {\n  return vec4((blend_lighten(vec3(a), vec3(b)) * b.a + vec3(a) * (1. - b.a)), a.a);\n}\n","src/blend/linearlight":"float blend_linearlight(float a, float b) {\n  return b < 0.5 ? max(a + 2. * b - 1., 0.) : min(a + 2. * (b - 0.5), 1.);\n}\n\nvec3 blend_linearlight(vec3 a, vec3 b) {\n  return vec3(\n    blend_linearlight(a.r, b.r),\n    blend_linearlight(a.g, b.g),\n    blend_linearlight(a.b, b.b)\n  );\n}\n\nvec4 blend_linearlight(vec4 a, vec4 b) {\n  return vec4((blend_linearlight(vec3(a), vec3(b)) * b.a + vec3(a) * (1. - b.a)), a.a);\n}\n","src/blend/multiply":"float blend_multiply(float a, float b) {\n  return a * b;\n}\n\nvec3 blend_multiply(vec3 a, vec3 b) {\n  return a * b;\n}\n\nvec4 blend_multiply(vec4 a, vec4 b) {\n  return vec4((blend_multiply(vec3(a), vec3(b)) * b.a + vec3(a) * (1. - b.a)), a.a);\n}\n","src/blend/negation":"float blend_negation(float a, float b) {\n  return 1. - abs(1. - a - b);\n}\n\nvec3 blend_negation(vec3 a, vec3 b) {\n  return vec3(1.) - abs(vec3(1.) - a - b);\n}\n\nvec4 blend_negation(vec4 a, vec4 b) {\n  return vec4((blend_negation(vec3(a), vec3(b)) * b.a + vec3(a) * (1. - b.a)), a.a);\n}\n","src/blend/normal":"float blend_normal(float a, float b) {\n  return b;\n}\n\nvec3 blend_normal(vec3 a, vec3 b) {\n  return b;\n}\n\nvec4 blend_normal(vec4 a, vec4 b) {\n  return vec4(vec3(b) * b.a + vec3(a) * (1. - b.a), a.a);\n}\n","src/blend/overlay":"float blend_overlay(float a, float b) {\n  return b < 0.5 ? 2. * a * b : 1. - (2. * (1. - a) * (1. - b));\n}\n\nvec3 blend_overlay(vec3 a, vec3 b) {\n  return vec3(\n    blend_overlay(a.r, b.r),\n    blend_overlay(a.g, b.g),\n    blend_overlay(a.b, b.b)\n  );\n}\n\nvec4 blend_overlay(vec4 a, vec4 b) {\n  return vec4((blend_overlay(vec3(a), vec3(b)) * b.a + vec3(a) * (1. - b.a)), a.a);\n}\n","src/blend/phoenix":"float blend_phoenix(float a, float b) {\n  return min(a, b) - max(a, b) + 1.;\n}\n\nvec3 blend_phoenix(vec3 a, vec3 b) {\n  return min(a, b) - max(a, b) + 1.;\n}\n\nvec4 blend_phoenix(vec4 a, vec4 b) {\n  return vec4((blend_phoenix(vec3(a), vec3(b)) * b.a + vec3(a) * (1. - b.a)), a.a);\n}\n","src/blend/pinlight":"float blend_pinlight(float a, float b) {\n  return b < 0.5 ? min(a, 2. * b) : max(a, 2. * (b - .5));\n}\n\nvec3 blend_pinlight(vec3 a, vec3 b) {\n  return vec3(\n    blend_pinlight(a.r, b.r),\n    blend_pinlight(a.g, b.g),\n    blend_pinlight(a.b, b.b)\n  );\n}\n\nvec4 blend_pinlight(vec4 a, vec4 b) {\n  return vec4((blend_pinlight(vec3(a), vec3(b)) * b.a + vec3(a) * (1. - b.a)), a.a);\n}\n","src/blend/reflect":"float blend_reflect(float a, float b) {\n  return b == 1. ? b : min(a * a / (1. - b), 1.);\n}\n\nvec3 blend_reflect(vec3 a, vec3 b) {\n  return vec3(\n    blend_reflect(a.r, b.r),\n    blend_reflect(a.g, b.g),\n    blend_reflect(a.b, b.b)\n  );\n}\n\nvec4 blend_reflect(vec4 a, vec4 b) {\n  return vec4((blend_reflect(vec3(a), vec3(b)) * b.a + vec3(a) * (1. - b.a)), a.a);\n}\n","src/blend/screen":"float blend_screen(float a, float b) {\n  return 1. - (1. - a) * (1. - b);\n}\n\nvec3 blend_screen(vec3 a, vec3 b) {\n  return 1. - (1. - a) * (1. - b);\n}\n\nvec4 blend_screen(vec4 a, vec4 b) {\n  return vec4((blend_screen(vec3(a), vec3(b)) * b.a + vec3(a) * (1. - b.a)), a.a);\n}\n","src/blend/softlight":"float blend_softlight(float a, float b) {\n  return b < 0.5 ? 2. * a * b + a * a * (1. - 2. * b) : sqrt(a) * (2. * b - 1.) + 2. * a * (1. - b);\n}\n\nvec3 blend_softlight(vec3 a, vec3 b) {\n  return vec3(\n    blend_softlight(a.r, b.r),\n    blend_softlight(a.g, b.g),\n    blend_softlight(a.b, b.b)\n  );\n}\n\nvec4 blend_softlight(vec4 a, vec4 b) {\n  return vec4((blend_softlight(vec3(a), vec3(b)) * b.a + vec3(a) * (1. - b.a)), a.a);\n}\n","src/blend/subtract":"float blend_substract(float a, float b) {\n  return max(a + b - 1., 0.);\n}\n\nvec3 blend_substract(vec3 a, vec3 b) {\n  return max(a + b - 1., 0.);\n}\n\nvec4 blend_substract(vec4 a, vec4 b) {\n  return vec4((blend_substract(vec3(a), vec3(b)) * b.a + vec3(a) * (1. - b.a)), a.a);\n}\n","src/blend/vividlight":"float blend_vividlight(float a, float b) {\n  return ( b < 0.5\n    ? ( b == 0. ? 2. * b : max(1. - (1. - a) / (2. * b), 0.) )\n    : ( 2. * (b - 0.5) == 1. ? 2. * (b - 0.5) : min(a / (1. - (2. * (b - 0.5))), 0.))\n  );\n}\n\nvec3 blend_vividlight(vec3 a, vec3 b) {\n  return vec3(\n    blend_vividlight(a.r, b.r),\n    blend_vividlight(a.g, b.g),\n    blend_vividlight(a.b, b.b)\n  );\n}\n\nvec4 blend_vividlight(vec4 a, vec4 b) {\n  return vec4((blend_vividlight(vec3(a), vec3(b)) * b.a + vec3(a) * (1. - b.a)), a.a);\n}\n","src/fbm":"#define NUM_OCTAVES 5\n\nfloat noise(float x);\nfloat noise(vec2 x);\nfloat noise(vec3 x);\n\nfloat fbm(float x) {\n  float v = 0.0;\n  float a = 0.5;\n  float shift = float(100);\n  for (int i = 0; i < NUM_OCTAVES; ++i) {\n    v += a * noise(x);\n    x = x * 2.0 + shift;\n    a *= 0.5;\n  }\n  return v;\n}\n\nfloat fbm(vec2 x) {\n  float v = 0.0;\n  float a = 0.5;\n  vec2 shift = vec2(100);\n  // Rotate to reduce axial bias\n  mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n  for (int i = 0; i < NUM_OCTAVES; ++i) {\n    v += a * noise(x);\n    x = rot * x * 2.0 + shift;\n    a *= 0.5;\n  }\n  return v;\n}\n\nfloat fbm(vec3 x) {\n  float v = 0.0;\n  float a = 0.5;\n  vec3 shift = vec3(100);\n  for (int i = 0; i < NUM_OCTAVES; ++i) {\n    v += a * noise(x);\n    x = x * 2.0 + shift;\n    a *= 0.5;\n  }\n  return v;\n}\n","src/gammacorrection":"vec3 gammacorrect(vec3 c, float g){\n  return pow(c, vec3(1./g));\n}\n","src/grayscale":"vec3 grayscale(vec3 c) {\n  return vec3(dot(c, vec3(0.299, 0.587, 0.114)));\n}\n","src/level":"vec3 level(vec3 c, float vmin, float vmax){\n  return min(max(c - vec3(vmin), vec3(.0)) / vec3(vmax - vmin), vec3(1.));\n}\n","src/noise":"float hash(float n) { return fract(sin(n) * 1e4); }\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\nfloat noise(float x) {\n        float i = floor(x);\n        float f = fract(x);\n        float u = f * f * (3.0 - 2.0 * f);\n        return mix(hash(i), hash(i + 1.0), u);\n}\n\nfloat noise(vec2 x) {\n        vec2 i = floor(x);\n        vec2 f = fract(x);\n\n        // Four corners in 2D of a tile\n        float a = hash(i);\n        float b = hash(i + vec2(1.0, 0.0));\n        float c = hash(i + vec2(0.0, 1.0));\n        float d = hash(i + vec2(1.0, 1.0));\n\n        // Simple 2D lerp using smoothstep envelope between the values.\n        // return vec3(mix(mix(a, b, smoothstep(0.0, 1.0, f.x)),\n        //                      mix(c, d, smoothstep(0.0, 1.0, f.x)),\n        //                      smoothstep(0.0, 1.0, f.y)));\n\n        // Same code, with the clamps in smoothstep and common subexpressions\n        // optimized away.\n        vec2 u = f * f * (3.0 - 2.0 * f);\n        return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n// This one has non-ideal tiling properties that I'm still tuning\nfloat noise(vec3 x) {\n        const vec3 step = vec3(110, 241, 171);\n\n        vec3 i = floor(x);\n        vec3 f = fract(x);\n \n        // For performance, compute the base input to a 1D hash from the integer part of the argument and the \n        // incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n        vec3 u = f * f * (3.0 - 2.0 * f);\n        return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\n","src/rand":"float rand(float v) {\n  return fract(sin(v * 43758.5453));\n}\n\nfloat randalt(float v) {\n  float y = fract(sin(v * 43758.5453) * 7533967.);\n  return y * 2. - (y > 0.5?1.:0.);\n}\n\nfloat rand(vec2 co) {\n  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 rand2(vec2 co) {\n  co = vec2(\n    dot(co, vec2(127.1, 311.7)),\n    dot(co, vec2(269.5, 183.3))\n  );\n  return -1. + 2. * fract(sin(co) * 43758.5453123);\n}\n\nfloat noise(vec2 co) {\n  vec2 i = floor(co);\n  vec2 f = fract(co);\n  vec2 u = f * f * (3. - 2. * f);\n  return mix(\n    mix( dot(rand2(i + vec2(0.,0.)), f - vec2(0.,0.)),\n         dot(rand2(i + vec2(1.,0.)), f - vec2(1.,0.)), u.x),\n    mix( dot(rand2(i + vec2(0.,1.)), f - vec2(0.,1.)),\n         dot(rand2(i + vec2(1.,1.)), f - vec2(1.,1.)), u.x), u.y\n  );\n}\n","src/sobel":"vec3 sobel(sampler2D txt, vec2 res, vec2 uv) {\n  float x = 1.0 / res.x;\n  float y = 1.0 / res.y;\n  vec4 h = vec4(.0), v = vec4(.0);\n  h = v = texture2D(txt, vec2(uv.x + x, uv.y + y)) - texture2D(txt, vec2(uv.x - x, uv.y - y));\n  h -= texture2D(txt, vec2(uv.x - x, uv.y)) * 2.;\n  h += texture2D(txt, vec2(uv.x + x, uv.y)) * 2.;\n  h -= texture2D(txt, vec2(uv.x - x, uv.y + y));\n  h += texture2D(txt, vec2(uv.x + x, uv.y - y));\n  v -= texture2D(txt, vec2(uv.x, uv.y - y)) * 2.;\n  v += texture2D(txt, vec2(uv.x, uv.y + y)) * 2.;\n  v -= texture2D(txt, vec2(uv.x + x, uv.y - y));\n  v += texture2D(txt, vec2(uv.x - x, uv.y + y));\n  return vec3(1. - sqrt(h * h + v * v));\n}\n","src/vignette":"float vignette(float max, float amount, vec2 uv) {\n  return max - length(uv - .5) * amount;\n}\n","src/wb":"vec3 wb(vec3 c, float threshold) {\n  return vec3(dot(c, vec3(0.299, 0.587, 0.114)) > threshold ? 1. : 0.);\n}\n"});